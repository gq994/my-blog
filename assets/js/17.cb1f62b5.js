(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{605:function(t,a,s){"use strict";s.r(a);var v=s(17),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"two"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#two"}},[t._v("#")]),t._v(" two")]),t._v(" "),s("h1",{attrs:{id:"什么是跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是跨域"}},[t._v("#")]),t._v(" 什么是跨域")]),t._v(" "),s("ul",[s("li",[t._v("浏览器都有同源策略 --- 协议 + 域名 + 端口 - 都相同")])]),t._v(" "),s("p",[t._v("http://    www     .     abc.com     :    8080      /      detail\n协议      子域名           主域名           端口            请求资源地址")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("同源策略限制了ajax请求")])]),t._v(" "),s("li",[s("p",[t._v("没有被同源策略所影响的三个标签")])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    <img src="xxx">\n    <link href="xxx">\n    <script src="xxx">\n')])])]),s("h1",{attrs:{id:"常见的跨域场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的跨域场景"}},[t._v("#")]),t._v(" 常见的跨域场景")]),t._v(" "),s("p",[t._v("http://www.a.com/a.js\nhttp://www.a.com/b.js   统一域名， 允许通信")]),t._v(" "),s("p",[t._v("http://www.a.com/a.js\nhttps://www.a.com/a.js   协议不同， 跨域")]),t._v(" "),s("p",[t._v("http://www.a.com/a.js\nhttp://w.a.com/a.js      主域相同，子域不同， 跨域")]),t._v(" "),s("h1",{attrs:{id:"特别说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特别说明"}},[t._v("#")]),t._v(" 特别说明")]),t._v(" "),s("ol",[s("li",[t._v("如果是端口和协议造成的跨域问题，前端是无法解决的")]),t._v(" "),s("li",[t._v("跨域仅仅是根据 url 的首部来识别，不会根据这个首部对应的ip地址来判断")]),t._v(" "),s("li",[t._v("跨域并不是请求没有发出去， 请求是梦发出去的， 服务器也是能响应的， 只是响应的结果浏览器拦截了")])]),t._v(" "),s("h1",{attrs:{id:"跨域的解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域的解决方案"}},[t._v("#")]),t._v(" 跨域的解决方案")]),t._v(" "),s("ol",[s("li",[t._v("jsonp")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("原理： 利用script标签中的src属性不会被同源策略拦截的这一机制，将我们要请求的url地址添加到script的src属性中， 且携带上前端全局下的一个函数名作为参数传给后端， 后端获取到前端传递的函数名，返回该函数的调用语法，将要返回的数据放到该函数的调用中作为参数， 当浏览器接收到全局下的函数被调用的后端响应， 就会自动执行该函数， 从而从参数中获取到后端返回的数据")])]),t._v(" "),s("li",[s("p",[t._v("缺点：")]),t._v(" "),s("ol",[s("li",[t._v("需要对方的服务器做支持才可以")]),t._v(" "),s("li",[t._v("只支持get请求， 有局限性， 可能遭到xss攻击")])])])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("cors")]),t._v(" "),s("ul",[s("li",[t._v("cors是W3C的标准， 它允许浏览器向跨源服务器发出XHLHttpRequest 请求。 也就是说浏览器发请求是不会被跨域的， 跨域的核心是后端响应不了。")])]),t._v(" "),s("p",[t._v("要让后端响应内容能够不被浏览器拦截，关键在于后端。 如果后端也能遵从 cors 标准的话， 后端的响应也可以跨源")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("简单请求\n· 使用 get post head\n· Content-Type的值仅限于\ntext/plain || multipart/from-data || application/x-www-from-urlencoded")])]),t._v(" "),s("li",[s("p",[t._v("复杂请求\n· 不满足简单请求的条件就是复杂请求\n· 复杂请求的cors请求会在正式通信之前增加一次http查询请求， 称为“预检”， 预检是用来知道服务端是否允许跨域请求，预检请求发的是options方法")])])])]),t._v(" "),s("li",[s("p",[t._v("postMessage")]),t._v(" "),s("ul",[s("li",[t._v("html5 中的 xhr 提供了API， postMessage() 方法允许来自不同源的脚本采用异步的方式进行有线通信， 可以实现跨文本， 多窗口， 跨域消息传递")])]),t._v(" "),s("p",[t._v("可以解决这么几个问题：")]),t._v(" "),s("ul",[s("li",[t._v("页面与其他新窗口的数据传递")]),t._v(" "),s("li",[t._v("多窗口之间的消息传递")]),t._v(" "),s("li",[t._v("页面与嵌套的iframe消息传递")]),t._v(" "),s("li",[t._v("上面三个场景的跨域数据传递")])]),t._v(" "),s("p",[t._v("otherWindow.postMessage(message, targetOrigin, [transfer])")]),t._v(" "),s("ul",[s("li",[t._v("message: 要发送给其他window的数据")]),t._v(" "),s("li",[t._v("targetOrigin： 目标窗口")]),t._v(" "),s("li",[t._v("transfer(可选) 和message一起传递的一个对象，这个对象的所有权将移交给消息接收方")])])])])])}),[],!1,null,null,null);a.default=_.exports}}]);