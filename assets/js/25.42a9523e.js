(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{610:function(a,e,t){"use strict";t.r(e);var n=t(17),r=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"第一题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一题"}},[a._v("#")]),a._v(" 第一题")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[1, 2, 3].map(parseInt)\n")])])]),t("ul",[t("li",[a._v("我们期望输出 [1, 2, 3], 而实际结果是 [1, NaN, NaN].")])]),a._v(" "),t("h2",{attrs:{id:"答案解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#答案解析"}},[a._v("#")]),a._v(" 答案解析")]),a._v(" "),t("ul",[t("li",[a._v("parseInt 经常被带着一个参数使用, 但是这里接受两个。第一个参数是一个表达式而第二个是callback function的基，Array.prototype.map 传递3个参数:\n"),t("ul",[t("li",[a._v("the element")]),a._v(" "),t("li",[a._v("the index")]),a._v(" "),t("li",[a._v("the array")])])]),a._v(" "),t("li",[a._v("第三个参数被 parseInt 忽视了，但不是第二个。因此可能出现混淆。下面是迭代步骤的简明示例：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('// parseInt(string, radix) -> map(parseInt(value, index))\n/*  first iteration (index is 0): */ parseInt("1", 0); // 1\n/* second iteration (index is 1): */ parseInt("2", 1); // NaN\n/*  third iteration (index is 2): */ parseInt("3", 2); // NaN\n')])])]),t("ul",[t("li",[a._v("下面让我们来讨论解决方案：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function returnInt(element) {\n  return parseInt(element, 10);\n}\n\n['1', '2', '3'].map(returnInt); // [1, 2, 3]\n// Actual result is an array of numbers (as expected)\n\n// Same as above, but using the concise arrow function syntax\n['1', '2', '3'].map( str => parseInt(str) );\n\n// A simpler way to achieve the above, while avoiding the \"gotcha\":\n['1', '2', '3'].map(Number); // [1, 2, 3]\n\n// But unlike parseInt(), Number() will also return a float or (resolved) exponential notation:\n['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300]\n// For comparison, if we use parseInt() on the array above:\n['1.1', '2.2e2', '3e300'].map( str => parseInt(str) ); // [1, 2, 3]\n")])])]),t("ul",[t("li",[a._v("一个 map 方法调用 parseInt 作为一个参数的等效输出运行如下:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var xs = ['10', '10', '10'];\n\nxs = xs.map(parseInt);\n\nconsole.log(xs);  // 输出结果为：[10, NaN, 2]\n// Actual result of 10,NaN,2 may be unexpected based on the above description.\n")])])]),t("h2",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" map()")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。")])]),a._v(" "),t("li",[t("p",[a._v("语法  var new_array = arr.map(function callback(currentValue[, index[, array]]) {\nReturn element for new_array\n}[, thisArg])")]),a._v(" "),t("ul",[t("li",[a._v("callback生成新数组元素的函数，使用三个参数：\n"),t("ul",[t("li",[a._v("currentValue\ncallback 数组中正在处理的当前元素。")]),a._v(" "),t("li",[a._v("index可选\ncallback 数组中正在处理的当前元素的索引。")]),a._v(" "),t("li",[a._v("array可选\nmap 方法调用的数组。")])])]),a._v(" "),t("li",[a._v("thisArg可选\n执行 callback 函数时值被用作this。")])])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var a = [1, 2, 3]\nvar b = a.map((item, index, arr) => {\n    console.log(item, index, arr);\n    return item * 2\n})\nconsole.log(b); // [2, 4, 6]\n// item, index, arr 返回结果为：\n// 1 0 [ 1, 2, 3 ]\n// 2 1 [ 1, 2, 3 ]\n// 3 2 [ 1, 2, 3 ]\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);