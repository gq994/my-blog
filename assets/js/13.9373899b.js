(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{595:function(t,a,s){"use strict";s.r(a);var r=s(17),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"这是three"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#这是three"}},[t._v("#")]),t._v(" 这是three")]),t._v(" "),s("h1",{attrs:{id:"ts"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ts"}},[t._v("#")]),t._v(" ts")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("在同一个文件夹不能出现同一个文件名")])]),t._v(" "),s("li",[s("p",[t._v("TS 只会在编译阶段对类型进行静态检查")])])]),t._v(" "),s("h1",{attrs:{id:"基础类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础类型"}},[t._v("#")]),t._v(" 基础类型")]),t._v(" "),s("h2",{attrs:{id:"stringnumbersymbolarrayenumanyunknowtuplevoidnullundefined"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stringnumbersymbolarrayenumanyunknowtuplevoidnullundefined"}},[t._v("#")]),t._v(" string\nnumber\nSymbol\nArray\nEnum\nany\nunknow\nTuple\nvoid\nnull\nundefined")]),t._v(" "),s("p",[t._v("object\n{}\nnever")]),t._v(" "),s("h1",{attrs:{id:"枚举"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#枚举"}},[t._v("#")]),t._v(" 枚举")]),t._v(" "),s("ul",[s("li",[t._v("数字枚举除了支持从成员名称到值得映射 还支持 从成员值到成员名称的 反向映射")])]),t._v(" "),s("h1",{attrs:{id:"ts-优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ts-优势"}},[t._v("#")]),t._v(" TS 优势")]),t._v(" "),s("ul",[s("li",[t._v("js报错在运行阶段， ts的报错实在编译阶段， 也就意味你可以直接看见错误代码")]),t._v(" "),s("li",[t._v("强类型限定是严格模式， 这种模式下写的代码不会存在类型带来的隐藏问题")])]),t._v(" "),s("h1",{attrs:{id:"ts中的函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ts中的函数"}},[t._v("#")]),t._v(" ts中的函数")]),t._v(" "),s("ul",[s("li",[t._v("1-9ts")])]),t._v(" "),s("h1",{attrs:{id:"ts中的类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ts中的类"}},[t._v("#")]),t._v(" ts中的类")])])}),[],!1,null,null,null);a.default=n.exports}}]);